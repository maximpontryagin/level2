package pattern

import "fmt"

/*
	Реализовать паттерн «посетитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Visitor_pattern
*/

/*
Суть паттерна:
Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции,
не изменяя классы объектов, над которыми эти операции могут выполняться.

Применимость:
1. Паттерн "Посетитель" используется, когда необходимо выполнить операции над объектами, находящимися в структуре
сложных объектов. При этом добавление новых операций должно происходить без изменения классов этих объектов.
2. Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.
3. Требуется добавить новый функционал, но избежать усложнения кода объекта.

Плюсы:
1. Упрощает добавление операций, работающих со сложными структурами объектов.
2. Объединяет родственные операции в одном классе.
3. Посетитель может накапливать состояние при обходе структуры элементов.

Минусы:
1. Паттерн не оправдан, если иерархия элементов часто меняется. При добавлении новых типов
элементов нужно изменять интерфейс посетителя и всех его реализаций.
2. Посетителю может понадобиться доступ к закрытым полям объектов, что нарушает инкапсуляцию.

Примеры:
1. Есть рабочий код структур и ее методов, на котором держится большая часть приложения
и менять который нельзя т.к. велик шанс что-то сломать. К примеру наш сервис собирает отчеты
и отправляет клиентам, однако нам понадобилось добавить возможность конвертировать отчет в формат excel,
и что бы не менять уже работающий код, от которого зависит большая часть приложения,
можно использовать паттерн посетитель.

Мой пример: У нас есть базовые структуры кошки и собаки в игре,
но нам необходимо добавить возможность их покормить не изменяя их код.
*/

// Интерфейс Animal, который должен реализовать каждый тип животного
type Animal interface {
	Accept(visitor AnimalVisitor)
}

// Структура Dog
type Dog struct {
	Name string
}

// Метод Accept для Dog, который принимает посетителя
func (d *Dog) Accept(visitor AnimalVisitor) {
	visitor.VisitDog(d)
}

// Структура Cat
type Cat struct {
	Name string
}

// Метод Accept для Cat, который принимает посетителя
func (c *Cat) Accept(visitor AnimalVisitor) {
	visitor.VisitCat(c)
}

// Интерфейс AnimalVisitor, который должен реализовать каждый посетитель
type AnimalVisitor interface {
	VisitDog(dog *Dog)
	VisitCat(cat *Cat)
}

// Посетитель EatVisitor, который заставляет животных есть
type EatVisitor struct{}

func (ev *EatVisitor) VisitDog(dog *Dog) {
	fmt.Printf("Собака %s кушает еду.\n", dog.Name)
}

func (ev *EatVisitor) VisitCat(cat *Cat) {
	fmt.Printf("Кошка %s кушает еду.\n", cat.Name)
}

func main() {
	// Создаем животных
	dog := &Dog{Name: "Арт - собака"}
	cat := &Cat{Name: "Бакс - кот"}

	// Создаем посетителя который учит кошек кушать
	eatVisitor := &EatVisitor{}

	// Заставляем животных есть
	dog.Accept(eatVisitor)
	cat.Accept(eatVisitor)
}
