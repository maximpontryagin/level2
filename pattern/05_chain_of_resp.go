package pattern

import "fmt"

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

/*
Суть паттерна:
Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы
последовательно по цепочке обработчиков. Каждый последующий обработчик решает,
может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

Применимость паттерна:
1. Когда программа должна обрабатывать разнообразные запросы несколькими способами,
но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
(последовательно опрашивая их запускать обработку или нет)
2. Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
3. Когда набор объектов, способных обработать запрос, должен задаваться динамически. В любой момент
можно вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

Плюсы:
1. Уменьшает зависимость между клиентом и обработчиками.
2. Реализует принцип единственной обязанности.
3. Реализует принцип открытости/закрытости.

Минусы:
1. Запрос может остаться никем не обработанным, но можно указать последнею дефолтную обработку.

Пример:
Валидация данных. Предположим, у нас есть система, которая обрабатывает пользовательские данные и должна
выполнять различные проверки (например, проверка формата, проверка на наличие обязательных полей, проверка
на соответствие бизнес-логике). Используя паттерн «Цепочка вызовов», мы можем организовать
процесс валидации таким образом, что каждый обработчик будет проверять определенный аспект данных
и передавать их следующему обработчику в цепочке, если проверка пройдена.

Мой пример:
В веб-приложении часто требуется обрабатывать HTTP-запросы с помощью различных middleware. Каждый middleware
может выполнять свою функцию, такую как логирование, аутентификация, авторизация, сжатие данных и т.д.
Используя паттерн «Цепочка вызовов», мы можем организовать процесс обработки запросов, где каждый middleware
будет обрабатывать запрос и передавать его следующему обработчику в цепочке.
*/

// Handler интерфейс для всех обработчиков
type Handler interface {
	SetNext(handler Handler) // Сюда передаем следующий обработчик
	Handle(request string)
}

// BaseHandler реализует общий функционал для всех обработчиков
type BaseHandler struct {
	next Handler
}

// SetNext устанавливает следующий обработчик в цепочке
func (h *BaseHandler) SetNext(handler Handler) {
	h.next = handler
}

// Handle вызывает следующий обработчик, если он существует
func (h *BaseHandler) Handle(request string) {
	if h.next != nil {
		h.next.Handle(request)
	}
}

// LoggingHandler обработчик для логирования запросов
type LoggingHandler struct {
	BaseHandler
}

// Handle логирует запрос и передает его следующему обработчику
func (h *LoggingHandler) Handle(request string) {
	fmt.Println("LoggingHandler: логирую запрос:", request)
	h.BaseHandler.Handle(request)
}

// AuthHandler обработчик для аутентификации запросов
type AuthHandler struct {
	BaseHandler
}

// Handle проверяет аутентификацию запроса и передает его следующему обработчику
func (h *AuthHandler) Handle(request string) {
	if request == "unauthenticated" {
		fmt.Println("AuthHandler: запрос не аутентифицирован")
	} else {
		fmt.Println("AuthHandler: запрос аутентифицирован")
		h.BaseHandler.Handle(request)
	}
}

// CompressHandler обработчик для сжатия данных
type CompressHandler struct {
	BaseHandler
}

// Handle сжимает данные запроса и передает его следующему обработчику
func (h *CompressHandler) Handle(request string) {
	fmt.Println("CompressHandler: сжимаю данные для запроса:", request)
	h.BaseHandler.Handle(request)
}

func main() {
	// Создаем обработчики
	loggingHandler := &LoggingHandler{}
	authHandler := &AuthHandler{}
	compressHandler := &CompressHandler{}

	// Устанавливаем цепочку обработчиков
	loggingHandler.SetNext(authHandler)
	authHandler.SetNext(compressHandler)

	// Тестовые запросы
	requests := []string{"validRequest", "unauthenticated", "anotherValidRequest"}

	for _, req := range requests {
		fmt.Println("Обработка запроса:", req)
		loggingHandler.Handle(req)
		fmt.Println("------")
	}
}
